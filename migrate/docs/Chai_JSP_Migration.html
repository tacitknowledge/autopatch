<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"><title>JSP Migration Service</title><meta name="author" content="Mike Hardy"></head><body><br>
<div style="text-align: center;">
<h2>JSP Migration Services<br>
</h2>
</div>
<small><span style="font-weight: bold;">Version:</span> $Id$<br>
<span style="font-weight: bold;">Author:</span> Mike Hardy, Nick Sophinos</small><br>
<br>
<hr style="height: 2px; width: 75%;"><br>
<b>Migrations allow for the front-end to have the power to upgrade itself when necessary.</b><br> 
<i>What does that mean?</i> It means that when we put a new build on the server, or deploy code to a customer, <br>
the front-end should check as to see if there any upgrades that need to run before all of the assumptions<br>
in the software are met.<br>
<br>
We call upgrades "migrations", and in the context of the front-end, a migration can be either a piece of logic<br>
(some Java code) or it can be just an XML file that needs to run on harmony. Each migration has a globally <br>
unique name, and does some work, basically.<br>
<br>
Some key requirements of migrations are:<br>
<ol>
  <li>a globally unique name</li>
  <li>the ability to just execute XML against harmony (picture a gigantic harmony-command-list file that contains<br>
      the configuration for a new customer's organization that should run when we deploy)</li>
  <li>the ability to execute Java code as a migration, in case someone needs complete control</li>
  <li>each migration should execute to completion once and only once</li>
  <li>the ability to specify the execution order of migrations</li>
</ol>
<p>
<h3>Implementation Details</h3>
<ol>
  <li>
    The <b>Migration</b> component extends GenericService and implements Comparable.  The Comparable implementation <br>
    compares the integer component property called <i>migrationNameDigits</i>.  This allows MigrationService to<br>
    call Collections.sort, causing the list of migration objects to order themselves the way the migration authors<br>
    intended.
  </li>
  <br>
  <li>
    The <b>Migration</b> component contains two abstract methods that match or closely match the harmony Migration interface.<br>
    The migration method throws a <i>FatalServiceException</i> on migration errors.   A FatalServiceException is a <br>
    subclass of ServiceException, used as the signal to abort completely, percolate it up the stack, and halt Core, bubbling<br>
    all the way out to ChaiServlet:init and finally bubbling out to Tomcat so its very clear that the server failed. 
  </li>
  <br>
  <li><b>There are 2 types of subclasses of the Migration Component:</b></li>
  <br>
  <ol>
    <li>
      An <b>XMLMigration</b> component sends the contents of a harmony command list file to harmony to perform the migration.<br>
      It takes a file name in the constructor, where it enforces filenames in the format of <tt>(\d+)_(\w+).xml</tt><br>
      The alpha chars become its XMLMigration instance name, the numeric chars become its ordering property.<br>
    </li>
    <br>
    <li>
      A <b>Java Migration</b> component sends the contents of a harmony command list property string to harmony to perform the<br>
      migration.  It sets its name and ordering value in its constructor via hard-coded values.<br>
    </li>
  </ol>
  </li>
  <br>
  <li>
    The <b>MigrationService</b> component that extends GenericService.  It is started by Core after HarmonyService and<br>
    ClassDiscoveryService and takes those two services as component properties.  It takes as a property a list of paths<br>
    to directories for XMLMigrations, and the list of packages that Java Migration class will be found in.<p>
    As an implementation of GenericService.preStart, it should:<br>
    &nbsp;&nbsp;1) use ClassDiscoveryService to find all Java Migration subclasses.<br>
    &nbsp;&nbsp;2) construct XMLMigration components for each XML file in the XML migration directories<br>
    &nbsp;&nbsp;3) sort all of these migrations so they're in whatever order the migration authors intended<br>
    &nbsp;&nbsp;4) for each migration, check harmony using <tt>getMigrationStatus()</tt> to see if its run, run it by calling the <tt>migrate()</tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method of the migration object if not. If the migration was successful, tell harmony to mark that migration name as<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;having run successfully with <tt>updateMigtrationStatus()</tt>.<br>
  </li>
</ol>
<p>
<p>
<b>With this system we'll have all the Java logic power we'll ever need to run complex migations when necessary, but the easy case <br>
will be easy: just drop an XML file in the tree, and you're set.</b><br>
</body>
</html>
